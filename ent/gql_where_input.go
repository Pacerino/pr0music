// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/Pacerino/pr0music/ent/comments"
	"github.com/Pacerino/pr0music/ent/items"
	"github.com/Pacerino/pr0music/ent/predicate"
)

// CommentsWhereInput represents a where input for filtering Comments queries.
type CommentsWhereInput struct {
	Predicates []predicate.Comments  `json:"-"`
	Not        *CommentsWhereInput   `json:"not,omitempty"`
	Or         []*CommentsWhereInput `json:"or,omitempty"`
	And        []*CommentsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "item_id" field predicates.
	ItemID      *int  `json:"itemID,omitempty"`
	ItemIDNEQ   *int  `json:"itemIDNEQ,omitempty"`
	ItemIDIn    []int `json:"itemIDIn,omitempty"`
	ItemIDNotIn []int `json:"itemIDNotIn,omitempty"`
	ItemIDGT    *int  `json:"itemIDGT,omitempty"`
	ItemIDGTE   *int  `json:"itemIDGTE,omitempty"`
	ItemIDLT    *int  `json:"itemIDLT,omitempty"`
	ItemIDLTE   *int  `json:"itemIDLTE,omitempty"`

	// "comment_id" field predicates.
	CommentID       *int  `json:"commentID,omitempty"`
	CommentIDNEQ    *int  `json:"commentIDNEQ,omitempty"`
	CommentIDIn     []int `json:"commentIDIn,omitempty"`
	CommentIDNotIn  []int `json:"commentIDNotIn,omitempty"`
	CommentIDGT     *int  `json:"commentIDGT,omitempty"`
	CommentIDGTE    *int  `json:"commentIDGTE,omitempty"`
	CommentIDLT     *int  `json:"commentIDLT,omitempty"`
	CommentIDLTE    *int  `json:"commentIDLTE,omitempty"`
	CommentIDIsNil  bool  `json:"commentIDIsNil,omitempty"`
	CommentIDNotNil bool  `json:"commentIDNotNil,omitempty"`

	// "up" field predicates.
	Up       *int  `json:"up,omitempty"`
	UpNEQ    *int  `json:"upNEQ,omitempty"`
	UpIn     []int `json:"upIn,omitempty"`
	UpNotIn  []int `json:"upNotIn,omitempty"`
	UpGT     *int  `json:"upGT,omitempty"`
	UpGTE    *int  `json:"upGTE,omitempty"`
	UpLT     *int  `json:"upLT,omitempty"`
	UpLTE    *int  `json:"upLTE,omitempty"`
	UpIsNil  bool  `json:"upIsNil,omitempty"`
	UpNotNil bool  `json:"upNotNil,omitempty"`

	// "down" field predicates.
	Down       *int  `json:"down,omitempty"`
	DownNEQ    *int  `json:"downNEQ,omitempty"`
	DownIn     []int `json:"downIn,omitempty"`
	DownNotIn  []int `json:"downNotIn,omitempty"`
	DownGT     *int  `json:"downGT,omitempty"`
	DownGTE    *int  `json:"downGTE,omitempty"`
	DownLT     *int  `json:"downLT,omitempty"`
	DownLTE    *int  `json:"downLTE,omitempty"`
	DownIsNil  bool  `json:"downIsNil,omitempty"`
	DownNotNil bool  `json:"downNotNil,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        bool     `json:"contentIsNil,omitempty"`
	ContentNotNil       bool     `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "created" field predicates.
	Created       *time.Time  `json:"created,omitempty"`
	CreatedNEQ    *time.Time  `json:"createdNEQ,omitempty"`
	CreatedIn     []time.Time `json:"createdIn,omitempty"`
	CreatedNotIn  []time.Time `json:"createdNotIn,omitempty"`
	CreatedGT     *time.Time  `json:"createdGT,omitempty"`
	CreatedGTE    *time.Time  `json:"createdGTE,omitempty"`
	CreatedLT     *time.Time  `json:"createdLT,omitempty"`
	CreatedLTE    *time.Time  `json:"createdLTE,omitempty"`
	CreatedIsNil  bool        `json:"createdIsNil,omitempty"`
	CreatedNotNil bool        `json:"createdNotNil,omitempty"`

	// "thumb" field predicates.
	Thumb             *string  `json:"thumb,omitempty"`
	ThumbNEQ          *string  `json:"thumbNEQ,omitempty"`
	ThumbIn           []string `json:"thumbIn,omitempty"`
	ThumbNotIn        []string `json:"thumbNotIn,omitempty"`
	ThumbGT           *string  `json:"thumbGT,omitempty"`
	ThumbGTE          *string  `json:"thumbGTE,omitempty"`
	ThumbLT           *string  `json:"thumbLT,omitempty"`
	ThumbLTE          *string  `json:"thumbLTE,omitempty"`
	ThumbContains     *string  `json:"thumbContains,omitempty"`
	ThumbHasPrefix    *string  `json:"thumbHasPrefix,omitempty"`
	ThumbHasSuffix    *string  `json:"thumbHasSuffix,omitempty"`
	ThumbIsNil        bool     `json:"thumbIsNil,omitempty"`
	ThumbNotNil       bool     `json:"thumbNotNil,omitempty"`
	ThumbEqualFold    *string  `json:"thumbEqualFold,omitempty"`
	ThumbContainsFold *string  `json:"thumbContainsFold,omitempty"`

	// "items" edge predicates.
	HasItems     *bool              `json:"hasItems,omitempty"`
	HasItemsWith []*ItemsWhereInput `json:"hasItemsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CommentsWhereInput) AddPredicates(predicates ...predicate.Comments) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CommentsWhereInput filter on the CommentsQuery builder.
func (i *CommentsWhereInput) Filter(q *CommentsQuery) (*CommentsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCommentsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCommentsWhereInput is returned in case the CommentsWhereInput is empty.
var ErrEmptyCommentsWhereInput = errors.New("ent: empty predicate CommentsWhereInput")

// P returns a predicate for filtering commentsslice.
// An error is returned if the input is empty or invalid.
func (i *CommentsWhereInput) P() (predicate.Comments, error) {
	var predicates []predicate.Comments
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, comments.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Comments, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, comments.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Comments, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, comments.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, comments.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, comments.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, comments.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, comments.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, comments.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, comments.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, comments.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, comments.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, comments.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, comments.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, comments.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, comments.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, comments.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, comments.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, comments.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, comments.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, comments.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, comments.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, comments.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, comments.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, comments.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, comments.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, comments.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, comments.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ItemID != nil {
		predicates = append(predicates, comments.ItemIDEQ(*i.ItemID))
	}
	if i.ItemIDNEQ != nil {
		predicates = append(predicates, comments.ItemIDNEQ(*i.ItemIDNEQ))
	}
	if len(i.ItemIDIn) > 0 {
		predicates = append(predicates, comments.ItemIDIn(i.ItemIDIn...))
	}
	if len(i.ItemIDNotIn) > 0 {
		predicates = append(predicates, comments.ItemIDNotIn(i.ItemIDNotIn...))
	}
	if i.ItemIDGT != nil {
		predicates = append(predicates, comments.ItemIDGT(*i.ItemIDGT))
	}
	if i.ItemIDGTE != nil {
		predicates = append(predicates, comments.ItemIDGTE(*i.ItemIDGTE))
	}
	if i.ItemIDLT != nil {
		predicates = append(predicates, comments.ItemIDLT(*i.ItemIDLT))
	}
	if i.ItemIDLTE != nil {
		predicates = append(predicates, comments.ItemIDLTE(*i.ItemIDLTE))
	}
	if i.CommentID != nil {
		predicates = append(predicates, comments.CommentIDEQ(*i.CommentID))
	}
	if i.CommentIDNEQ != nil {
		predicates = append(predicates, comments.CommentIDNEQ(*i.CommentIDNEQ))
	}
	if len(i.CommentIDIn) > 0 {
		predicates = append(predicates, comments.CommentIDIn(i.CommentIDIn...))
	}
	if len(i.CommentIDNotIn) > 0 {
		predicates = append(predicates, comments.CommentIDNotIn(i.CommentIDNotIn...))
	}
	if i.CommentIDGT != nil {
		predicates = append(predicates, comments.CommentIDGT(*i.CommentIDGT))
	}
	if i.CommentIDGTE != nil {
		predicates = append(predicates, comments.CommentIDGTE(*i.CommentIDGTE))
	}
	if i.CommentIDLT != nil {
		predicates = append(predicates, comments.CommentIDLT(*i.CommentIDLT))
	}
	if i.CommentIDLTE != nil {
		predicates = append(predicates, comments.CommentIDLTE(*i.CommentIDLTE))
	}
	if i.CommentIDIsNil {
		predicates = append(predicates, comments.CommentIDIsNil())
	}
	if i.CommentIDNotNil {
		predicates = append(predicates, comments.CommentIDNotNil())
	}
	if i.Up != nil {
		predicates = append(predicates, comments.UpEQ(*i.Up))
	}
	if i.UpNEQ != nil {
		predicates = append(predicates, comments.UpNEQ(*i.UpNEQ))
	}
	if len(i.UpIn) > 0 {
		predicates = append(predicates, comments.UpIn(i.UpIn...))
	}
	if len(i.UpNotIn) > 0 {
		predicates = append(predicates, comments.UpNotIn(i.UpNotIn...))
	}
	if i.UpGT != nil {
		predicates = append(predicates, comments.UpGT(*i.UpGT))
	}
	if i.UpGTE != nil {
		predicates = append(predicates, comments.UpGTE(*i.UpGTE))
	}
	if i.UpLT != nil {
		predicates = append(predicates, comments.UpLT(*i.UpLT))
	}
	if i.UpLTE != nil {
		predicates = append(predicates, comments.UpLTE(*i.UpLTE))
	}
	if i.UpIsNil {
		predicates = append(predicates, comments.UpIsNil())
	}
	if i.UpNotNil {
		predicates = append(predicates, comments.UpNotNil())
	}
	if i.Down != nil {
		predicates = append(predicates, comments.DownEQ(*i.Down))
	}
	if i.DownNEQ != nil {
		predicates = append(predicates, comments.DownNEQ(*i.DownNEQ))
	}
	if len(i.DownIn) > 0 {
		predicates = append(predicates, comments.DownIn(i.DownIn...))
	}
	if len(i.DownNotIn) > 0 {
		predicates = append(predicates, comments.DownNotIn(i.DownNotIn...))
	}
	if i.DownGT != nil {
		predicates = append(predicates, comments.DownGT(*i.DownGT))
	}
	if i.DownGTE != nil {
		predicates = append(predicates, comments.DownGTE(*i.DownGTE))
	}
	if i.DownLT != nil {
		predicates = append(predicates, comments.DownLT(*i.DownLT))
	}
	if i.DownLTE != nil {
		predicates = append(predicates, comments.DownLTE(*i.DownLTE))
	}
	if i.DownIsNil {
		predicates = append(predicates, comments.DownIsNil())
	}
	if i.DownNotNil {
		predicates = append(predicates, comments.DownNotNil())
	}
	if i.Content != nil {
		predicates = append(predicates, comments.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, comments.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, comments.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, comments.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, comments.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, comments.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, comments.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, comments.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, comments.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, comments.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, comments.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentIsNil {
		predicates = append(predicates, comments.ContentIsNil())
	}
	if i.ContentNotNil {
		predicates = append(predicates, comments.ContentNotNil())
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, comments.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, comments.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.Created != nil {
		predicates = append(predicates, comments.CreatedEQ(*i.Created))
	}
	if i.CreatedNEQ != nil {
		predicates = append(predicates, comments.CreatedNEQ(*i.CreatedNEQ))
	}
	if len(i.CreatedIn) > 0 {
		predicates = append(predicates, comments.CreatedIn(i.CreatedIn...))
	}
	if len(i.CreatedNotIn) > 0 {
		predicates = append(predicates, comments.CreatedNotIn(i.CreatedNotIn...))
	}
	if i.CreatedGT != nil {
		predicates = append(predicates, comments.CreatedGT(*i.CreatedGT))
	}
	if i.CreatedGTE != nil {
		predicates = append(predicates, comments.CreatedGTE(*i.CreatedGTE))
	}
	if i.CreatedLT != nil {
		predicates = append(predicates, comments.CreatedLT(*i.CreatedLT))
	}
	if i.CreatedLTE != nil {
		predicates = append(predicates, comments.CreatedLTE(*i.CreatedLTE))
	}
	if i.CreatedIsNil {
		predicates = append(predicates, comments.CreatedIsNil())
	}
	if i.CreatedNotNil {
		predicates = append(predicates, comments.CreatedNotNil())
	}
	if i.Thumb != nil {
		predicates = append(predicates, comments.ThumbEQ(*i.Thumb))
	}
	if i.ThumbNEQ != nil {
		predicates = append(predicates, comments.ThumbNEQ(*i.ThumbNEQ))
	}
	if len(i.ThumbIn) > 0 {
		predicates = append(predicates, comments.ThumbIn(i.ThumbIn...))
	}
	if len(i.ThumbNotIn) > 0 {
		predicates = append(predicates, comments.ThumbNotIn(i.ThumbNotIn...))
	}
	if i.ThumbGT != nil {
		predicates = append(predicates, comments.ThumbGT(*i.ThumbGT))
	}
	if i.ThumbGTE != nil {
		predicates = append(predicates, comments.ThumbGTE(*i.ThumbGTE))
	}
	if i.ThumbLT != nil {
		predicates = append(predicates, comments.ThumbLT(*i.ThumbLT))
	}
	if i.ThumbLTE != nil {
		predicates = append(predicates, comments.ThumbLTE(*i.ThumbLTE))
	}
	if i.ThumbContains != nil {
		predicates = append(predicates, comments.ThumbContains(*i.ThumbContains))
	}
	if i.ThumbHasPrefix != nil {
		predicates = append(predicates, comments.ThumbHasPrefix(*i.ThumbHasPrefix))
	}
	if i.ThumbHasSuffix != nil {
		predicates = append(predicates, comments.ThumbHasSuffix(*i.ThumbHasSuffix))
	}
	if i.ThumbIsNil {
		predicates = append(predicates, comments.ThumbIsNil())
	}
	if i.ThumbNotNil {
		predicates = append(predicates, comments.ThumbNotNil())
	}
	if i.ThumbEqualFold != nil {
		predicates = append(predicates, comments.ThumbEqualFold(*i.ThumbEqualFold))
	}
	if i.ThumbContainsFold != nil {
		predicates = append(predicates, comments.ThumbContainsFold(*i.ThumbContainsFold))
	}

	if i.HasItems != nil {
		p := comments.HasItems()
		if !*i.HasItems {
			p = comments.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.Items, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, comments.HasItemsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCommentsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return comments.And(predicates...), nil
	}
}

// ItemsWhereInput represents a where input for filtering Items queries.
type ItemsWhereInput struct {
	Predicates []predicate.Items  `json:"-"`
	Not        *ItemsWhereInput   `json:"not,omitempty"`
	Or         []*ItemsWhereInput `json:"or,omitempty"`
	And        []*ItemsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "item_id" field predicates.
	ItemID      *int  `json:"itemID,omitempty"`
	ItemIDNEQ   *int  `json:"itemIDNEQ,omitempty"`
	ItemIDIn    []int `json:"itemIDIn,omitempty"`
	ItemIDNotIn []int `json:"itemIDNotIn,omitempty"`
	ItemIDGT    *int  `json:"itemIDGT,omitempty"`
	ItemIDGTE   *int  `json:"itemIDGTE,omitempty"`
	ItemIDLT    *int  `json:"itemIDLT,omitempty"`
	ItemIDLTE   *int  `json:"itemIDLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "album" field predicates.
	Album             *string  `json:"album,omitempty"`
	AlbumNEQ          *string  `json:"albumNEQ,omitempty"`
	AlbumIn           []string `json:"albumIn,omitempty"`
	AlbumNotIn        []string `json:"albumNotIn,omitempty"`
	AlbumGT           *string  `json:"albumGT,omitempty"`
	AlbumGTE          *string  `json:"albumGTE,omitempty"`
	AlbumLT           *string  `json:"albumLT,omitempty"`
	AlbumLTE          *string  `json:"albumLTE,omitempty"`
	AlbumContains     *string  `json:"albumContains,omitempty"`
	AlbumHasPrefix    *string  `json:"albumHasPrefix,omitempty"`
	AlbumHasSuffix    *string  `json:"albumHasSuffix,omitempty"`
	AlbumIsNil        bool     `json:"albumIsNil,omitempty"`
	AlbumNotNil       bool     `json:"albumNotNil,omitempty"`
	AlbumEqualFold    *string  `json:"albumEqualFold,omitempty"`
	AlbumContainsFold *string  `json:"albumContainsFold,omitempty"`

	// "artist" field predicates.
	Artist             *string  `json:"artist,omitempty"`
	ArtistNEQ          *string  `json:"artistNEQ,omitempty"`
	ArtistIn           []string `json:"artistIn,omitempty"`
	ArtistNotIn        []string `json:"artistNotIn,omitempty"`
	ArtistGT           *string  `json:"artistGT,omitempty"`
	ArtistGTE          *string  `json:"artistGTE,omitempty"`
	ArtistLT           *string  `json:"artistLT,omitempty"`
	ArtistLTE          *string  `json:"artistLTE,omitempty"`
	ArtistContains     *string  `json:"artistContains,omitempty"`
	ArtistHasPrefix    *string  `json:"artistHasPrefix,omitempty"`
	ArtistHasSuffix    *string  `json:"artistHasSuffix,omitempty"`
	ArtistIsNil        bool     `json:"artistIsNil,omitempty"`
	ArtistNotNil       bool     `json:"artistNotNil,omitempty"`
	ArtistEqualFold    *string  `json:"artistEqualFold,omitempty"`
	ArtistContainsFold *string  `json:"artistContainsFold,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        bool     `json:"urlIsNil,omitempty"`
	URLNotNil       bool     `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "acr_id" field predicates.
	AcrID             *string  `json:"acrID,omitempty"`
	AcrIDNEQ          *string  `json:"acrIDNEQ,omitempty"`
	AcrIDIn           []string `json:"acrIDIn,omitempty"`
	AcrIDNotIn        []string `json:"acrIDNotIn,omitempty"`
	AcrIDGT           *string  `json:"acrIDGT,omitempty"`
	AcrIDGTE          *string  `json:"acrIDGTE,omitempty"`
	AcrIDLT           *string  `json:"acrIDLT,omitempty"`
	AcrIDLTE          *string  `json:"acrIDLTE,omitempty"`
	AcrIDContains     *string  `json:"acrIDContains,omitempty"`
	AcrIDHasPrefix    *string  `json:"acrIDHasPrefix,omitempty"`
	AcrIDHasSuffix    *string  `json:"acrIDHasSuffix,omitempty"`
	AcrIDIsNil        bool     `json:"acrIDIsNil,omitempty"`
	AcrIDNotNil       bool     `json:"acrIDNotNil,omitempty"`
	AcrIDEqualFold    *string  `json:"acrIDEqualFold,omitempty"`
	AcrIDContainsFold *string  `json:"acrIDContainsFold,omitempty"`

	// "spotify_url" field predicates.
	SpotifyURL             *string  `json:"spotifyURL,omitempty"`
	SpotifyURLNEQ          *string  `json:"spotifyURLNEQ,omitempty"`
	SpotifyURLIn           []string `json:"spotifyURLIn,omitempty"`
	SpotifyURLNotIn        []string `json:"spotifyURLNotIn,omitempty"`
	SpotifyURLGT           *string  `json:"spotifyURLGT,omitempty"`
	SpotifyURLGTE          *string  `json:"spotifyURLGTE,omitempty"`
	SpotifyURLLT           *string  `json:"spotifyURLLT,omitempty"`
	SpotifyURLLTE          *string  `json:"spotifyURLLTE,omitempty"`
	SpotifyURLContains     *string  `json:"spotifyURLContains,omitempty"`
	SpotifyURLHasPrefix    *string  `json:"spotifyURLHasPrefix,omitempty"`
	SpotifyURLHasSuffix    *string  `json:"spotifyURLHasSuffix,omitempty"`
	SpotifyURLIsNil        bool     `json:"spotifyURLIsNil,omitempty"`
	SpotifyURLNotNil       bool     `json:"spotifyURLNotNil,omitempty"`
	SpotifyURLEqualFold    *string  `json:"spotifyURLEqualFold,omitempty"`
	SpotifyURLContainsFold *string  `json:"spotifyURLContainsFold,omitempty"`

	// "spotify_id" field predicates.
	SpotifyID             *string  `json:"spotifyID,omitempty"`
	SpotifyIDNEQ          *string  `json:"spotifyIDNEQ,omitempty"`
	SpotifyIDIn           []string `json:"spotifyIDIn,omitempty"`
	SpotifyIDNotIn        []string `json:"spotifyIDNotIn,omitempty"`
	SpotifyIDGT           *string  `json:"spotifyIDGT,omitempty"`
	SpotifyIDGTE          *string  `json:"spotifyIDGTE,omitempty"`
	SpotifyIDLT           *string  `json:"spotifyIDLT,omitempty"`
	SpotifyIDLTE          *string  `json:"spotifyIDLTE,omitempty"`
	SpotifyIDContains     *string  `json:"spotifyIDContains,omitempty"`
	SpotifyIDHasPrefix    *string  `json:"spotifyIDHasPrefix,omitempty"`
	SpotifyIDHasSuffix    *string  `json:"spotifyIDHasSuffix,omitempty"`
	SpotifyIDIsNil        bool     `json:"spotifyIDIsNil,omitempty"`
	SpotifyIDNotNil       bool     `json:"spotifyIDNotNil,omitempty"`
	SpotifyIDEqualFold    *string  `json:"spotifyIDEqualFold,omitempty"`
	SpotifyIDContainsFold *string  `json:"spotifyIDContainsFold,omitempty"`

	// "youtube_url" field predicates.
	YoutubeURL             *string  `json:"youtubeURL,omitempty"`
	YoutubeURLNEQ          *string  `json:"youtubeURLNEQ,omitempty"`
	YoutubeURLIn           []string `json:"youtubeURLIn,omitempty"`
	YoutubeURLNotIn        []string `json:"youtubeURLNotIn,omitempty"`
	YoutubeURLGT           *string  `json:"youtubeURLGT,omitempty"`
	YoutubeURLGTE          *string  `json:"youtubeURLGTE,omitempty"`
	YoutubeURLLT           *string  `json:"youtubeURLLT,omitempty"`
	YoutubeURLLTE          *string  `json:"youtubeURLLTE,omitempty"`
	YoutubeURLContains     *string  `json:"youtubeURLContains,omitempty"`
	YoutubeURLHasPrefix    *string  `json:"youtubeURLHasPrefix,omitempty"`
	YoutubeURLHasSuffix    *string  `json:"youtubeURLHasSuffix,omitempty"`
	YoutubeURLIsNil        bool     `json:"youtubeURLIsNil,omitempty"`
	YoutubeURLNotNil       bool     `json:"youtubeURLNotNil,omitempty"`
	YoutubeURLEqualFold    *string  `json:"youtubeURLEqualFold,omitempty"`
	YoutubeURLContainsFold *string  `json:"youtubeURLContainsFold,omitempty"`

	// "youtube_id" field predicates.
	YoutubeID             *string  `json:"youtubeID,omitempty"`
	YoutubeIDNEQ          *string  `json:"youtubeIDNEQ,omitempty"`
	YoutubeIDIn           []string `json:"youtubeIDIn,omitempty"`
	YoutubeIDNotIn        []string `json:"youtubeIDNotIn,omitempty"`
	YoutubeIDGT           *string  `json:"youtubeIDGT,omitempty"`
	YoutubeIDGTE          *string  `json:"youtubeIDGTE,omitempty"`
	YoutubeIDLT           *string  `json:"youtubeIDLT,omitempty"`
	YoutubeIDLTE          *string  `json:"youtubeIDLTE,omitempty"`
	YoutubeIDContains     *string  `json:"youtubeIDContains,omitempty"`
	YoutubeIDHasPrefix    *string  `json:"youtubeIDHasPrefix,omitempty"`
	YoutubeIDHasSuffix    *string  `json:"youtubeIDHasSuffix,omitempty"`
	YoutubeIDIsNil        bool     `json:"youtubeIDIsNil,omitempty"`
	YoutubeIDNotNil       bool     `json:"youtubeIDNotNil,omitempty"`
	YoutubeIDEqualFold    *string  `json:"youtubeIDEqualFold,omitempty"`
	YoutubeIDContainsFold *string  `json:"youtubeIDContainsFold,omitempty"`

	// "comments" edge predicates.
	HasComments     *bool                 `json:"hasComments,omitempty"`
	HasCommentsWith []*CommentsWhereInput `json:"hasCommentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ItemsWhereInput) AddPredicates(predicates ...predicate.Items) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ItemsWhereInput filter on the ItemsQuery builder.
func (i *ItemsWhereInput) Filter(q *ItemsQuery) (*ItemsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyItemsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyItemsWhereInput is returned in case the ItemsWhereInput is empty.
var ErrEmptyItemsWhereInput = errors.New("ent: empty predicate ItemsWhereInput")

// P returns a predicate for filtering itemsslice.
// An error is returned if the input is empty or invalid.
func (i *ItemsWhereInput) P() (predicate.Items, error) {
	var predicates []predicate.Items
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, items.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Items, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, items.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Items, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, items.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, items.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, items.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, items.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, items.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, items.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, items.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, items.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, items.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, items.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, items.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, items.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, items.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, items.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, items.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, items.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, items.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, items.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, items.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, items.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, items.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, items.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, items.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, items.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, items.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ItemID != nil {
		predicates = append(predicates, items.ItemIDEQ(*i.ItemID))
	}
	if i.ItemIDNEQ != nil {
		predicates = append(predicates, items.ItemIDNEQ(*i.ItemIDNEQ))
	}
	if len(i.ItemIDIn) > 0 {
		predicates = append(predicates, items.ItemIDIn(i.ItemIDIn...))
	}
	if len(i.ItemIDNotIn) > 0 {
		predicates = append(predicates, items.ItemIDNotIn(i.ItemIDNotIn...))
	}
	if i.ItemIDGT != nil {
		predicates = append(predicates, items.ItemIDGT(*i.ItemIDGT))
	}
	if i.ItemIDGTE != nil {
		predicates = append(predicates, items.ItemIDGTE(*i.ItemIDGTE))
	}
	if i.ItemIDLT != nil {
		predicates = append(predicates, items.ItemIDLT(*i.ItemIDLT))
	}
	if i.ItemIDLTE != nil {
		predicates = append(predicates, items.ItemIDLTE(*i.ItemIDLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, items.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, items.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, items.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, items.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, items.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, items.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, items.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, items.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, items.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, items.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, items.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, items.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, items.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, items.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, items.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Album != nil {
		predicates = append(predicates, items.AlbumEQ(*i.Album))
	}
	if i.AlbumNEQ != nil {
		predicates = append(predicates, items.AlbumNEQ(*i.AlbumNEQ))
	}
	if len(i.AlbumIn) > 0 {
		predicates = append(predicates, items.AlbumIn(i.AlbumIn...))
	}
	if len(i.AlbumNotIn) > 0 {
		predicates = append(predicates, items.AlbumNotIn(i.AlbumNotIn...))
	}
	if i.AlbumGT != nil {
		predicates = append(predicates, items.AlbumGT(*i.AlbumGT))
	}
	if i.AlbumGTE != nil {
		predicates = append(predicates, items.AlbumGTE(*i.AlbumGTE))
	}
	if i.AlbumLT != nil {
		predicates = append(predicates, items.AlbumLT(*i.AlbumLT))
	}
	if i.AlbumLTE != nil {
		predicates = append(predicates, items.AlbumLTE(*i.AlbumLTE))
	}
	if i.AlbumContains != nil {
		predicates = append(predicates, items.AlbumContains(*i.AlbumContains))
	}
	if i.AlbumHasPrefix != nil {
		predicates = append(predicates, items.AlbumHasPrefix(*i.AlbumHasPrefix))
	}
	if i.AlbumHasSuffix != nil {
		predicates = append(predicates, items.AlbumHasSuffix(*i.AlbumHasSuffix))
	}
	if i.AlbumIsNil {
		predicates = append(predicates, items.AlbumIsNil())
	}
	if i.AlbumNotNil {
		predicates = append(predicates, items.AlbumNotNil())
	}
	if i.AlbumEqualFold != nil {
		predicates = append(predicates, items.AlbumEqualFold(*i.AlbumEqualFold))
	}
	if i.AlbumContainsFold != nil {
		predicates = append(predicates, items.AlbumContainsFold(*i.AlbumContainsFold))
	}
	if i.Artist != nil {
		predicates = append(predicates, items.ArtistEQ(*i.Artist))
	}
	if i.ArtistNEQ != nil {
		predicates = append(predicates, items.ArtistNEQ(*i.ArtistNEQ))
	}
	if len(i.ArtistIn) > 0 {
		predicates = append(predicates, items.ArtistIn(i.ArtistIn...))
	}
	if len(i.ArtistNotIn) > 0 {
		predicates = append(predicates, items.ArtistNotIn(i.ArtistNotIn...))
	}
	if i.ArtistGT != nil {
		predicates = append(predicates, items.ArtistGT(*i.ArtistGT))
	}
	if i.ArtistGTE != nil {
		predicates = append(predicates, items.ArtistGTE(*i.ArtistGTE))
	}
	if i.ArtistLT != nil {
		predicates = append(predicates, items.ArtistLT(*i.ArtistLT))
	}
	if i.ArtistLTE != nil {
		predicates = append(predicates, items.ArtistLTE(*i.ArtistLTE))
	}
	if i.ArtistContains != nil {
		predicates = append(predicates, items.ArtistContains(*i.ArtistContains))
	}
	if i.ArtistHasPrefix != nil {
		predicates = append(predicates, items.ArtistHasPrefix(*i.ArtistHasPrefix))
	}
	if i.ArtistHasSuffix != nil {
		predicates = append(predicates, items.ArtistHasSuffix(*i.ArtistHasSuffix))
	}
	if i.ArtistIsNil {
		predicates = append(predicates, items.ArtistIsNil())
	}
	if i.ArtistNotNil {
		predicates = append(predicates, items.ArtistNotNil())
	}
	if i.ArtistEqualFold != nil {
		predicates = append(predicates, items.ArtistEqualFold(*i.ArtistEqualFold))
	}
	if i.ArtistContainsFold != nil {
		predicates = append(predicates, items.ArtistContainsFold(*i.ArtistContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, items.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, items.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, items.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, items.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, items.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, items.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, items.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, items.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, items.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, items.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, items.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLIsNil {
		predicates = append(predicates, items.URLIsNil())
	}
	if i.URLNotNil {
		predicates = append(predicates, items.URLNotNil())
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, items.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, items.URLContainsFold(*i.URLContainsFold))
	}
	if i.AcrID != nil {
		predicates = append(predicates, items.AcrIDEQ(*i.AcrID))
	}
	if i.AcrIDNEQ != nil {
		predicates = append(predicates, items.AcrIDNEQ(*i.AcrIDNEQ))
	}
	if len(i.AcrIDIn) > 0 {
		predicates = append(predicates, items.AcrIDIn(i.AcrIDIn...))
	}
	if len(i.AcrIDNotIn) > 0 {
		predicates = append(predicates, items.AcrIDNotIn(i.AcrIDNotIn...))
	}
	if i.AcrIDGT != nil {
		predicates = append(predicates, items.AcrIDGT(*i.AcrIDGT))
	}
	if i.AcrIDGTE != nil {
		predicates = append(predicates, items.AcrIDGTE(*i.AcrIDGTE))
	}
	if i.AcrIDLT != nil {
		predicates = append(predicates, items.AcrIDLT(*i.AcrIDLT))
	}
	if i.AcrIDLTE != nil {
		predicates = append(predicates, items.AcrIDLTE(*i.AcrIDLTE))
	}
	if i.AcrIDContains != nil {
		predicates = append(predicates, items.AcrIDContains(*i.AcrIDContains))
	}
	if i.AcrIDHasPrefix != nil {
		predicates = append(predicates, items.AcrIDHasPrefix(*i.AcrIDHasPrefix))
	}
	if i.AcrIDHasSuffix != nil {
		predicates = append(predicates, items.AcrIDHasSuffix(*i.AcrIDHasSuffix))
	}
	if i.AcrIDIsNil {
		predicates = append(predicates, items.AcrIDIsNil())
	}
	if i.AcrIDNotNil {
		predicates = append(predicates, items.AcrIDNotNil())
	}
	if i.AcrIDEqualFold != nil {
		predicates = append(predicates, items.AcrIDEqualFold(*i.AcrIDEqualFold))
	}
	if i.AcrIDContainsFold != nil {
		predicates = append(predicates, items.AcrIDContainsFold(*i.AcrIDContainsFold))
	}
	if i.SpotifyURL != nil {
		predicates = append(predicates, items.SpotifyURLEQ(*i.SpotifyURL))
	}
	if i.SpotifyURLNEQ != nil {
		predicates = append(predicates, items.SpotifyURLNEQ(*i.SpotifyURLNEQ))
	}
	if len(i.SpotifyURLIn) > 0 {
		predicates = append(predicates, items.SpotifyURLIn(i.SpotifyURLIn...))
	}
	if len(i.SpotifyURLNotIn) > 0 {
		predicates = append(predicates, items.SpotifyURLNotIn(i.SpotifyURLNotIn...))
	}
	if i.SpotifyURLGT != nil {
		predicates = append(predicates, items.SpotifyURLGT(*i.SpotifyURLGT))
	}
	if i.SpotifyURLGTE != nil {
		predicates = append(predicates, items.SpotifyURLGTE(*i.SpotifyURLGTE))
	}
	if i.SpotifyURLLT != nil {
		predicates = append(predicates, items.SpotifyURLLT(*i.SpotifyURLLT))
	}
	if i.SpotifyURLLTE != nil {
		predicates = append(predicates, items.SpotifyURLLTE(*i.SpotifyURLLTE))
	}
	if i.SpotifyURLContains != nil {
		predicates = append(predicates, items.SpotifyURLContains(*i.SpotifyURLContains))
	}
	if i.SpotifyURLHasPrefix != nil {
		predicates = append(predicates, items.SpotifyURLHasPrefix(*i.SpotifyURLHasPrefix))
	}
	if i.SpotifyURLHasSuffix != nil {
		predicates = append(predicates, items.SpotifyURLHasSuffix(*i.SpotifyURLHasSuffix))
	}
	if i.SpotifyURLIsNil {
		predicates = append(predicates, items.SpotifyURLIsNil())
	}
	if i.SpotifyURLNotNil {
		predicates = append(predicates, items.SpotifyURLNotNil())
	}
	if i.SpotifyURLEqualFold != nil {
		predicates = append(predicates, items.SpotifyURLEqualFold(*i.SpotifyURLEqualFold))
	}
	if i.SpotifyURLContainsFold != nil {
		predicates = append(predicates, items.SpotifyURLContainsFold(*i.SpotifyURLContainsFold))
	}
	if i.SpotifyID != nil {
		predicates = append(predicates, items.SpotifyIDEQ(*i.SpotifyID))
	}
	if i.SpotifyIDNEQ != nil {
		predicates = append(predicates, items.SpotifyIDNEQ(*i.SpotifyIDNEQ))
	}
	if len(i.SpotifyIDIn) > 0 {
		predicates = append(predicates, items.SpotifyIDIn(i.SpotifyIDIn...))
	}
	if len(i.SpotifyIDNotIn) > 0 {
		predicates = append(predicates, items.SpotifyIDNotIn(i.SpotifyIDNotIn...))
	}
	if i.SpotifyIDGT != nil {
		predicates = append(predicates, items.SpotifyIDGT(*i.SpotifyIDGT))
	}
	if i.SpotifyIDGTE != nil {
		predicates = append(predicates, items.SpotifyIDGTE(*i.SpotifyIDGTE))
	}
	if i.SpotifyIDLT != nil {
		predicates = append(predicates, items.SpotifyIDLT(*i.SpotifyIDLT))
	}
	if i.SpotifyIDLTE != nil {
		predicates = append(predicates, items.SpotifyIDLTE(*i.SpotifyIDLTE))
	}
	if i.SpotifyIDContains != nil {
		predicates = append(predicates, items.SpotifyIDContains(*i.SpotifyIDContains))
	}
	if i.SpotifyIDHasPrefix != nil {
		predicates = append(predicates, items.SpotifyIDHasPrefix(*i.SpotifyIDHasPrefix))
	}
	if i.SpotifyIDHasSuffix != nil {
		predicates = append(predicates, items.SpotifyIDHasSuffix(*i.SpotifyIDHasSuffix))
	}
	if i.SpotifyIDIsNil {
		predicates = append(predicates, items.SpotifyIDIsNil())
	}
	if i.SpotifyIDNotNil {
		predicates = append(predicates, items.SpotifyIDNotNil())
	}
	if i.SpotifyIDEqualFold != nil {
		predicates = append(predicates, items.SpotifyIDEqualFold(*i.SpotifyIDEqualFold))
	}
	if i.SpotifyIDContainsFold != nil {
		predicates = append(predicates, items.SpotifyIDContainsFold(*i.SpotifyIDContainsFold))
	}
	if i.YoutubeURL != nil {
		predicates = append(predicates, items.YoutubeURLEQ(*i.YoutubeURL))
	}
	if i.YoutubeURLNEQ != nil {
		predicates = append(predicates, items.YoutubeURLNEQ(*i.YoutubeURLNEQ))
	}
	if len(i.YoutubeURLIn) > 0 {
		predicates = append(predicates, items.YoutubeURLIn(i.YoutubeURLIn...))
	}
	if len(i.YoutubeURLNotIn) > 0 {
		predicates = append(predicates, items.YoutubeURLNotIn(i.YoutubeURLNotIn...))
	}
	if i.YoutubeURLGT != nil {
		predicates = append(predicates, items.YoutubeURLGT(*i.YoutubeURLGT))
	}
	if i.YoutubeURLGTE != nil {
		predicates = append(predicates, items.YoutubeURLGTE(*i.YoutubeURLGTE))
	}
	if i.YoutubeURLLT != nil {
		predicates = append(predicates, items.YoutubeURLLT(*i.YoutubeURLLT))
	}
	if i.YoutubeURLLTE != nil {
		predicates = append(predicates, items.YoutubeURLLTE(*i.YoutubeURLLTE))
	}
	if i.YoutubeURLContains != nil {
		predicates = append(predicates, items.YoutubeURLContains(*i.YoutubeURLContains))
	}
	if i.YoutubeURLHasPrefix != nil {
		predicates = append(predicates, items.YoutubeURLHasPrefix(*i.YoutubeURLHasPrefix))
	}
	if i.YoutubeURLHasSuffix != nil {
		predicates = append(predicates, items.YoutubeURLHasSuffix(*i.YoutubeURLHasSuffix))
	}
	if i.YoutubeURLIsNil {
		predicates = append(predicates, items.YoutubeURLIsNil())
	}
	if i.YoutubeURLNotNil {
		predicates = append(predicates, items.YoutubeURLNotNil())
	}
	if i.YoutubeURLEqualFold != nil {
		predicates = append(predicates, items.YoutubeURLEqualFold(*i.YoutubeURLEqualFold))
	}
	if i.YoutubeURLContainsFold != nil {
		predicates = append(predicates, items.YoutubeURLContainsFold(*i.YoutubeURLContainsFold))
	}
	if i.YoutubeID != nil {
		predicates = append(predicates, items.YoutubeIDEQ(*i.YoutubeID))
	}
	if i.YoutubeIDNEQ != nil {
		predicates = append(predicates, items.YoutubeIDNEQ(*i.YoutubeIDNEQ))
	}
	if len(i.YoutubeIDIn) > 0 {
		predicates = append(predicates, items.YoutubeIDIn(i.YoutubeIDIn...))
	}
	if len(i.YoutubeIDNotIn) > 0 {
		predicates = append(predicates, items.YoutubeIDNotIn(i.YoutubeIDNotIn...))
	}
	if i.YoutubeIDGT != nil {
		predicates = append(predicates, items.YoutubeIDGT(*i.YoutubeIDGT))
	}
	if i.YoutubeIDGTE != nil {
		predicates = append(predicates, items.YoutubeIDGTE(*i.YoutubeIDGTE))
	}
	if i.YoutubeIDLT != nil {
		predicates = append(predicates, items.YoutubeIDLT(*i.YoutubeIDLT))
	}
	if i.YoutubeIDLTE != nil {
		predicates = append(predicates, items.YoutubeIDLTE(*i.YoutubeIDLTE))
	}
	if i.YoutubeIDContains != nil {
		predicates = append(predicates, items.YoutubeIDContains(*i.YoutubeIDContains))
	}
	if i.YoutubeIDHasPrefix != nil {
		predicates = append(predicates, items.YoutubeIDHasPrefix(*i.YoutubeIDHasPrefix))
	}
	if i.YoutubeIDHasSuffix != nil {
		predicates = append(predicates, items.YoutubeIDHasSuffix(*i.YoutubeIDHasSuffix))
	}
	if i.YoutubeIDIsNil {
		predicates = append(predicates, items.YoutubeIDIsNil())
	}
	if i.YoutubeIDNotNil {
		predicates = append(predicates, items.YoutubeIDNotNil())
	}
	if i.YoutubeIDEqualFold != nil {
		predicates = append(predicates, items.YoutubeIDEqualFold(*i.YoutubeIDEqualFold))
	}
	if i.YoutubeIDContainsFold != nil {
		predicates = append(predicates, items.YoutubeIDContainsFold(*i.YoutubeIDContainsFold))
	}

	if i.HasComments != nil {
		p := items.HasComments()
		if !*i.HasComments {
			p = items.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCommentsWith) > 0 {
		with := make([]predicate.Comments, 0, len(i.HasCommentsWith))
		for _, w := range i.HasCommentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCommentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, items.HasCommentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyItemsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return items.And(predicates...), nil
	}
}
