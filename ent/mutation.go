// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/Pacerino/pr0music/ent/comments"
	"github.com/Pacerino/pr0music/ent/items"
	"github.com/Pacerino/pr0music/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeComments = "Comments"
	TypeItems    = "Items"
)

// CommentsMutation represents an operation that mutates the Comments nodes in the graph.
type CommentsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	item_id       *int
	additem_id    *int
	comment_id    *int
	addcomment_id *int
	up            *int
	addup         *int
	down          *int
	adddown       *int
	content       *string
	created       *time.Time
	thumb         *string
	clearedFields map[string]struct{}
	items         *int
	cleareditems  bool
	done          bool
	oldValue      func(context.Context) (*Comments, error)
	predicates    []predicate.Comments
}

var _ ent.Mutation = (*CommentsMutation)(nil)

// commentsOption allows management of the mutation configuration using functional options.
type commentsOption func(*CommentsMutation)

// newCommentsMutation creates new mutation for the Comments entity.
func newCommentsMutation(c config, op Op, opts ...commentsOption) *CommentsMutation {
	m := &CommentsMutation{
		config:        c,
		op:            op,
		typ:           TypeComments,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentsID sets the ID field of the mutation.
func withCommentsID(id int) commentsOption {
	return func(m *CommentsMutation) {
		var (
			err   error
			once  sync.Once
			value *Comments
		)
		m.oldValue = func(ctx context.Context) (*Comments, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comments.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComments sets the old Comments of the mutation.
func withComments(node *Comments) commentsOption {
	return func(m *CommentsMutation) {
		m.oldValue = func(context.Context) (*Comments, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comments.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetItemID sets the "item_id" field.
func (m *CommentsMutation) SetItemID(i int) {
	m.item_id = &i
	m.additem_id = nil
}

// ItemID returns the value of the "item_id" field in the mutation.
func (m *CommentsMutation) ItemID() (r int, exists bool) {
	v := m.item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldItemID returns the old "item_id" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldItemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemID: %w", err)
	}
	return oldValue.ItemID, nil
}

// AddItemID adds i to the "item_id" field.
func (m *CommentsMutation) AddItemID(i int) {
	if m.additem_id != nil {
		*m.additem_id += i
	} else {
		m.additem_id = &i
	}
}

// AddedItemID returns the value that was added to the "item_id" field in this mutation.
func (m *CommentsMutation) AddedItemID() (r int, exists bool) {
	v := m.additem_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemID resets all changes to the "item_id" field.
func (m *CommentsMutation) ResetItemID() {
	m.item_id = nil
	m.additem_id = nil
}

// SetCommentID sets the "comment_id" field.
func (m *CommentsMutation) SetCommentID(i int) {
	m.comment_id = &i
	m.addcomment_id = nil
}

// CommentID returns the value of the "comment_id" field in the mutation.
func (m *CommentsMutation) CommentID() (r int, exists bool) {
	v := m.comment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentID returns the old "comment_id" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldCommentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentID: %w", err)
	}
	return oldValue.CommentID, nil
}

// AddCommentID adds i to the "comment_id" field.
func (m *CommentsMutation) AddCommentID(i int) {
	if m.addcomment_id != nil {
		*m.addcomment_id += i
	} else {
		m.addcomment_id = &i
	}
}

// AddedCommentID returns the value that was added to the "comment_id" field in this mutation.
func (m *CommentsMutation) AddedCommentID() (r int, exists bool) {
	v := m.addcomment_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCommentID clears the value of the "comment_id" field.
func (m *CommentsMutation) ClearCommentID() {
	m.comment_id = nil
	m.addcomment_id = nil
	m.clearedFields[comments.FieldCommentID] = struct{}{}
}

// CommentIDCleared returns if the "comment_id" field was cleared in this mutation.
func (m *CommentsMutation) CommentIDCleared() bool {
	_, ok := m.clearedFields[comments.FieldCommentID]
	return ok
}

// ResetCommentID resets all changes to the "comment_id" field.
func (m *CommentsMutation) ResetCommentID() {
	m.comment_id = nil
	m.addcomment_id = nil
	delete(m.clearedFields, comments.FieldCommentID)
}

// SetUp sets the "up" field.
func (m *CommentsMutation) SetUp(i int) {
	m.up = &i
	m.addup = nil
}

// Up returns the value of the "up" field in the mutation.
func (m *CommentsMutation) Up() (r int, exists bool) {
	v := m.up
	if v == nil {
		return
	}
	return *v, true
}

// OldUp returns the old "up" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldUp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUp: %w", err)
	}
	return oldValue.Up, nil
}

// AddUp adds i to the "up" field.
func (m *CommentsMutation) AddUp(i int) {
	if m.addup != nil {
		*m.addup += i
	} else {
		m.addup = &i
	}
}

// AddedUp returns the value that was added to the "up" field in this mutation.
func (m *CommentsMutation) AddedUp() (r int, exists bool) {
	v := m.addup
	if v == nil {
		return
	}
	return *v, true
}

// ClearUp clears the value of the "up" field.
func (m *CommentsMutation) ClearUp() {
	m.up = nil
	m.addup = nil
	m.clearedFields[comments.FieldUp] = struct{}{}
}

// UpCleared returns if the "up" field was cleared in this mutation.
func (m *CommentsMutation) UpCleared() bool {
	_, ok := m.clearedFields[comments.FieldUp]
	return ok
}

// ResetUp resets all changes to the "up" field.
func (m *CommentsMutation) ResetUp() {
	m.up = nil
	m.addup = nil
	delete(m.clearedFields, comments.FieldUp)
}

// SetDown sets the "down" field.
func (m *CommentsMutation) SetDown(i int) {
	m.down = &i
	m.adddown = nil
}

// Down returns the value of the "down" field in the mutation.
func (m *CommentsMutation) Down() (r int, exists bool) {
	v := m.down
	if v == nil {
		return
	}
	return *v, true
}

// OldDown returns the old "down" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldDown(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDown: %w", err)
	}
	return oldValue.Down, nil
}

// AddDown adds i to the "down" field.
func (m *CommentsMutation) AddDown(i int) {
	if m.adddown != nil {
		*m.adddown += i
	} else {
		m.adddown = &i
	}
}

// AddedDown returns the value that was added to the "down" field in this mutation.
func (m *CommentsMutation) AddedDown() (r int, exists bool) {
	v := m.adddown
	if v == nil {
		return
	}
	return *v, true
}

// ClearDown clears the value of the "down" field.
func (m *CommentsMutation) ClearDown() {
	m.down = nil
	m.adddown = nil
	m.clearedFields[comments.FieldDown] = struct{}{}
}

// DownCleared returns if the "down" field was cleared in this mutation.
func (m *CommentsMutation) DownCleared() bool {
	_, ok := m.clearedFields[comments.FieldDown]
	return ok
}

// ResetDown resets all changes to the "down" field.
func (m *CommentsMutation) ResetDown() {
	m.down = nil
	m.adddown = nil
	delete(m.clearedFields, comments.FieldDown)
}

// SetContent sets the "content" field.
func (m *CommentsMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentsMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *CommentsMutation) ClearContent() {
	m.content = nil
	m.clearedFields[comments.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *CommentsMutation) ContentCleared() bool {
	_, ok := m.clearedFields[comments.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *CommentsMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, comments.FieldContent)
}

// SetCreated sets the "created" field.
func (m *CommentsMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *CommentsMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ClearCreated clears the value of the "created" field.
func (m *CommentsMutation) ClearCreated() {
	m.created = nil
	m.clearedFields[comments.FieldCreated] = struct{}{}
}

// CreatedCleared returns if the "created" field was cleared in this mutation.
func (m *CommentsMutation) CreatedCleared() bool {
	_, ok := m.clearedFields[comments.FieldCreated]
	return ok
}

// ResetCreated resets all changes to the "created" field.
func (m *CommentsMutation) ResetCreated() {
	m.created = nil
	delete(m.clearedFields, comments.FieldCreated)
}

// SetThumb sets the "thumb" field.
func (m *CommentsMutation) SetThumb(s string) {
	m.thumb = &s
}

// Thumb returns the value of the "thumb" field in the mutation.
func (m *CommentsMutation) Thumb() (r string, exists bool) {
	v := m.thumb
	if v == nil {
		return
	}
	return *v, true
}

// OldThumb returns the old "thumb" field's value of the Comments entity.
// If the Comments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentsMutation) OldThumb(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumb: %w", err)
	}
	return oldValue.Thumb, nil
}

// ClearThumb clears the value of the "thumb" field.
func (m *CommentsMutation) ClearThumb() {
	m.thumb = nil
	m.clearedFields[comments.FieldThumb] = struct{}{}
}

// ThumbCleared returns if the "thumb" field was cleared in this mutation.
func (m *CommentsMutation) ThumbCleared() bool {
	_, ok := m.clearedFields[comments.FieldThumb]
	return ok
}

// ResetThumb resets all changes to the "thumb" field.
func (m *CommentsMutation) ResetThumb() {
	m.thumb = nil
	delete(m.clearedFields, comments.FieldThumb)
}

// SetItemsID sets the "items" edge to the Items entity by id.
func (m *CommentsMutation) SetItemsID(id int) {
	m.items = &id
}

// ClearItems clears the "items" edge to the Items entity.
func (m *CommentsMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Items entity was cleared.
func (m *CommentsMutation) ItemsCleared() bool {
	return m.cleareditems
}

// ItemsID returns the "items" edge ID in the mutation.
func (m *CommentsMutation) ItemsID() (id int, exists bool) {
	if m.items != nil {
		return *m.items, true
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemsID instead. It exists only for internal usage by the builders.
func (m *CommentsMutation) ItemsIDs() (ids []int) {
	if id := m.items; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *CommentsMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
}

// Where appends a list predicates to the CommentsMutation builder.
func (m *CommentsMutation) Where(ps ...predicate.Comments) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommentsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Comments).
func (m *CommentsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, comments.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comments.FieldUpdatedAt)
	}
	if m.item_id != nil {
		fields = append(fields, comments.FieldItemID)
	}
	if m.comment_id != nil {
		fields = append(fields, comments.FieldCommentID)
	}
	if m.up != nil {
		fields = append(fields, comments.FieldUp)
	}
	if m.down != nil {
		fields = append(fields, comments.FieldDown)
	}
	if m.content != nil {
		fields = append(fields, comments.FieldContent)
	}
	if m.created != nil {
		fields = append(fields, comments.FieldCreated)
	}
	if m.thumb != nil {
		fields = append(fields, comments.FieldThumb)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comments.FieldCreatedAt:
		return m.CreatedAt()
	case comments.FieldUpdatedAt:
		return m.UpdatedAt()
	case comments.FieldItemID:
		return m.ItemID()
	case comments.FieldCommentID:
		return m.CommentID()
	case comments.FieldUp:
		return m.Up()
	case comments.FieldDown:
		return m.Down()
	case comments.FieldContent:
		return m.Content()
	case comments.FieldCreated:
		return m.Created()
	case comments.FieldThumb:
		return m.Thumb()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comments.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comments.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comments.FieldItemID:
		return m.OldItemID(ctx)
	case comments.FieldCommentID:
		return m.OldCommentID(ctx)
	case comments.FieldUp:
		return m.OldUp(ctx)
	case comments.FieldDown:
		return m.OldDown(ctx)
	case comments.FieldContent:
		return m.OldContent(ctx)
	case comments.FieldCreated:
		return m.OldCreated(ctx)
	case comments.FieldThumb:
		return m.OldThumb(ctx)
	}
	return nil, fmt.Errorf("unknown Comments field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comments.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comments.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comments.FieldItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemID(v)
		return nil
	case comments.FieldCommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentID(v)
		return nil
	case comments.FieldUp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUp(v)
		return nil
	case comments.FieldDown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDown(v)
		return nil
	case comments.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comments.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case comments.FieldThumb:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumb(v)
		return nil
	}
	return fmt.Errorf("unknown Comments field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentsMutation) AddedFields() []string {
	var fields []string
	if m.additem_id != nil {
		fields = append(fields, comments.FieldItemID)
	}
	if m.addcomment_id != nil {
		fields = append(fields, comments.FieldCommentID)
	}
	if m.addup != nil {
		fields = append(fields, comments.FieldUp)
	}
	if m.adddown != nil {
		fields = append(fields, comments.FieldDown)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comments.FieldItemID:
		return m.AddedItemID()
	case comments.FieldCommentID:
		return m.AddedCommentID()
	case comments.FieldUp:
		return m.AddedUp()
	case comments.FieldDown:
		return m.AddedDown()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comments.FieldItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemID(v)
		return nil
	case comments.FieldCommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentID(v)
		return nil
	case comments.FieldUp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUp(v)
		return nil
	case comments.FieldDown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDown(v)
		return nil
	}
	return fmt.Errorf("unknown Comments numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comments.FieldCommentID) {
		fields = append(fields, comments.FieldCommentID)
	}
	if m.FieldCleared(comments.FieldUp) {
		fields = append(fields, comments.FieldUp)
	}
	if m.FieldCleared(comments.FieldDown) {
		fields = append(fields, comments.FieldDown)
	}
	if m.FieldCleared(comments.FieldContent) {
		fields = append(fields, comments.FieldContent)
	}
	if m.FieldCleared(comments.FieldCreated) {
		fields = append(fields, comments.FieldCreated)
	}
	if m.FieldCleared(comments.FieldThumb) {
		fields = append(fields, comments.FieldThumb)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentsMutation) ClearField(name string) error {
	switch name {
	case comments.FieldCommentID:
		m.ClearCommentID()
		return nil
	case comments.FieldUp:
		m.ClearUp()
		return nil
	case comments.FieldDown:
		m.ClearDown()
		return nil
	case comments.FieldContent:
		m.ClearContent()
		return nil
	case comments.FieldCreated:
		m.ClearCreated()
		return nil
	case comments.FieldThumb:
		m.ClearThumb()
		return nil
	}
	return fmt.Errorf("unknown Comments nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentsMutation) ResetField(name string) error {
	switch name {
	case comments.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comments.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comments.FieldItemID:
		m.ResetItemID()
		return nil
	case comments.FieldCommentID:
		m.ResetCommentID()
		return nil
	case comments.FieldUp:
		m.ResetUp()
		return nil
	case comments.FieldDown:
		m.ResetDown()
		return nil
	case comments.FieldContent:
		m.ResetContent()
		return nil
	case comments.FieldCreated:
		m.ResetCreated()
		return nil
	case comments.FieldThumb:
		m.ResetThumb()
		return nil
	}
	return fmt.Errorf("unknown Comments field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.items != nil {
		edges = append(edges, comments.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comments.EdgeItems:
		if id := m.items; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareditems {
		edges = append(edges, comments.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentsMutation) EdgeCleared(name string) bool {
	switch name {
	case comments.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentsMutation) ClearEdge(name string) error {
	switch name {
	case comments.EdgeItems:
		m.ClearItems()
		return nil
	}
	return fmt.Errorf("unknown Comments unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentsMutation) ResetEdge(name string) error {
	switch name {
	case comments.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown Comments edge %s", name)
}

// ItemsMutation represents an operation that mutates the Items nodes in the graph.
type ItemsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	item_id         *int
	additem_id      *int
	title           *string
	album           *string
	artist          *string
	url             *string
	acr_id          *string
	spotify_url     *string
	spotify_id      *string
	youtube_url     *string
	youtube_id      *string
	clearedFields   map[string]struct{}
	comments        map[int]struct{}
	removedcomments map[int]struct{}
	clearedcomments bool
	done            bool
	oldValue        func(context.Context) (*Items, error)
	predicates      []predicate.Items
}

var _ ent.Mutation = (*ItemsMutation)(nil)

// itemsOption allows management of the mutation configuration using functional options.
type itemsOption func(*ItemsMutation)

// newItemsMutation creates new mutation for the Items entity.
func newItemsMutation(c config, op Op, opts ...itemsOption) *ItemsMutation {
	m := &ItemsMutation{
		config:        c,
		op:            op,
		typ:           TypeItems,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withItemsID sets the ID field of the mutation.
func withItemsID(id int) itemsOption {
	return func(m *ItemsMutation) {
		var (
			err   error
			once  sync.Once
			value *Items
		)
		m.oldValue = func(ctx context.Context) (*Items, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Items.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItems sets the old Items of the mutation.
func withItems(node *Items) itemsOption {
	return func(m *ItemsMutation) {
		m.oldValue = func(context.Context) (*Items, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ItemsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ItemsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ItemsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ItemsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Items.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ItemsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ItemsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Items entity.
// If the Items object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ItemsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ItemsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ItemsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Items entity.
// If the Items object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ItemsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetItemID sets the "item_id" field.
func (m *ItemsMutation) SetItemID(i int) {
	m.item_id = &i
	m.additem_id = nil
}

// ItemID returns the value of the "item_id" field in the mutation.
func (m *ItemsMutation) ItemID() (r int, exists bool) {
	v := m.item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldItemID returns the old "item_id" field's value of the Items entity.
// If the Items object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemsMutation) OldItemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemID: %w", err)
	}
	return oldValue.ItemID, nil
}

// AddItemID adds i to the "item_id" field.
func (m *ItemsMutation) AddItemID(i int) {
	if m.additem_id != nil {
		*m.additem_id += i
	} else {
		m.additem_id = &i
	}
}

// AddedItemID returns the value that was added to the "item_id" field in this mutation.
func (m *ItemsMutation) AddedItemID() (r int, exists bool) {
	v := m.additem_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemID resets all changes to the "item_id" field.
func (m *ItemsMutation) ResetItemID() {
	m.item_id = nil
	m.additem_id = nil
}

// SetTitle sets the "title" field.
func (m *ItemsMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ItemsMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Items entity.
// If the Items object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemsMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ItemsMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[items.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ItemsMutation) TitleCleared() bool {
	_, ok := m.clearedFields[items.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ItemsMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, items.FieldTitle)
}

// SetAlbum sets the "album" field.
func (m *ItemsMutation) SetAlbum(s string) {
	m.album = &s
}

// Album returns the value of the "album" field in the mutation.
func (m *ItemsMutation) Album() (r string, exists bool) {
	v := m.album
	if v == nil {
		return
	}
	return *v, true
}

// OldAlbum returns the old "album" field's value of the Items entity.
// If the Items object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemsMutation) OldAlbum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlbum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlbum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlbum: %w", err)
	}
	return oldValue.Album, nil
}

// ClearAlbum clears the value of the "album" field.
func (m *ItemsMutation) ClearAlbum() {
	m.album = nil
	m.clearedFields[items.FieldAlbum] = struct{}{}
}

// AlbumCleared returns if the "album" field was cleared in this mutation.
func (m *ItemsMutation) AlbumCleared() bool {
	_, ok := m.clearedFields[items.FieldAlbum]
	return ok
}

// ResetAlbum resets all changes to the "album" field.
func (m *ItemsMutation) ResetAlbum() {
	m.album = nil
	delete(m.clearedFields, items.FieldAlbum)
}

// SetArtist sets the "artist" field.
func (m *ItemsMutation) SetArtist(s string) {
	m.artist = &s
}

// Artist returns the value of the "artist" field in the mutation.
func (m *ItemsMutation) Artist() (r string, exists bool) {
	v := m.artist
	if v == nil {
		return
	}
	return *v, true
}

// OldArtist returns the old "artist" field's value of the Items entity.
// If the Items object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemsMutation) OldArtist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtist: %w", err)
	}
	return oldValue.Artist, nil
}

// ClearArtist clears the value of the "artist" field.
func (m *ItemsMutation) ClearArtist() {
	m.artist = nil
	m.clearedFields[items.FieldArtist] = struct{}{}
}

// ArtistCleared returns if the "artist" field was cleared in this mutation.
func (m *ItemsMutation) ArtistCleared() bool {
	_, ok := m.clearedFields[items.FieldArtist]
	return ok
}

// ResetArtist resets all changes to the "artist" field.
func (m *ItemsMutation) ResetArtist() {
	m.artist = nil
	delete(m.clearedFields, items.FieldArtist)
}

// SetURL sets the "url" field.
func (m *ItemsMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ItemsMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Items entity.
// If the Items object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemsMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ItemsMutation) ClearURL() {
	m.url = nil
	m.clearedFields[items.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ItemsMutation) URLCleared() bool {
	_, ok := m.clearedFields[items.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ItemsMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, items.FieldURL)
}

// SetAcrID sets the "acr_id" field.
func (m *ItemsMutation) SetAcrID(s string) {
	m.acr_id = &s
}

// AcrID returns the value of the "acr_id" field in the mutation.
func (m *ItemsMutation) AcrID() (r string, exists bool) {
	v := m.acr_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAcrID returns the old "acr_id" field's value of the Items entity.
// If the Items object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemsMutation) OldAcrID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcrID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcrID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcrID: %w", err)
	}
	return oldValue.AcrID, nil
}

// ClearAcrID clears the value of the "acr_id" field.
func (m *ItemsMutation) ClearAcrID() {
	m.acr_id = nil
	m.clearedFields[items.FieldAcrID] = struct{}{}
}

// AcrIDCleared returns if the "acr_id" field was cleared in this mutation.
func (m *ItemsMutation) AcrIDCleared() bool {
	_, ok := m.clearedFields[items.FieldAcrID]
	return ok
}

// ResetAcrID resets all changes to the "acr_id" field.
func (m *ItemsMutation) ResetAcrID() {
	m.acr_id = nil
	delete(m.clearedFields, items.FieldAcrID)
}

// SetSpotifyURL sets the "spotify_url" field.
func (m *ItemsMutation) SetSpotifyURL(s string) {
	m.spotify_url = &s
}

// SpotifyURL returns the value of the "spotify_url" field in the mutation.
func (m *ItemsMutation) SpotifyURL() (r string, exists bool) {
	v := m.spotify_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSpotifyURL returns the old "spotify_url" field's value of the Items entity.
// If the Items object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemsMutation) OldSpotifyURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpotifyURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpotifyURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpotifyURL: %w", err)
	}
	return oldValue.SpotifyURL, nil
}

// ClearSpotifyURL clears the value of the "spotify_url" field.
func (m *ItemsMutation) ClearSpotifyURL() {
	m.spotify_url = nil
	m.clearedFields[items.FieldSpotifyURL] = struct{}{}
}

// SpotifyURLCleared returns if the "spotify_url" field was cleared in this mutation.
func (m *ItemsMutation) SpotifyURLCleared() bool {
	_, ok := m.clearedFields[items.FieldSpotifyURL]
	return ok
}

// ResetSpotifyURL resets all changes to the "spotify_url" field.
func (m *ItemsMutation) ResetSpotifyURL() {
	m.spotify_url = nil
	delete(m.clearedFields, items.FieldSpotifyURL)
}

// SetSpotifyID sets the "spotify_id" field.
func (m *ItemsMutation) SetSpotifyID(s string) {
	m.spotify_id = &s
}

// SpotifyID returns the value of the "spotify_id" field in the mutation.
func (m *ItemsMutation) SpotifyID() (r string, exists bool) {
	v := m.spotify_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpotifyID returns the old "spotify_id" field's value of the Items entity.
// If the Items object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemsMutation) OldSpotifyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpotifyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpotifyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpotifyID: %w", err)
	}
	return oldValue.SpotifyID, nil
}

// ClearSpotifyID clears the value of the "spotify_id" field.
func (m *ItemsMutation) ClearSpotifyID() {
	m.spotify_id = nil
	m.clearedFields[items.FieldSpotifyID] = struct{}{}
}

// SpotifyIDCleared returns if the "spotify_id" field was cleared in this mutation.
func (m *ItemsMutation) SpotifyIDCleared() bool {
	_, ok := m.clearedFields[items.FieldSpotifyID]
	return ok
}

// ResetSpotifyID resets all changes to the "spotify_id" field.
func (m *ItemsMutation) ResetSpotifyID() {
	m.spotify_id = nil
	delete(m.clearedFields, items.FieldSpotifyID)
}

// SetYoutubeURL sets the "youtube_url" field.
func (m *ItemsMutation) SetYoutubeURL(s string) {
	m.youtube_url = &s
}

// YoutubeURL returns the value of the "youtube_url" field in the mutation.
func (m *ItemsMutation) YoutubeURL() (r string, exists bool) {
	v := m.youtube_url
	if v == nil {
		return
	}
	return *v, true
}

// OldYoutubeURL returns the old "youtube_url" field's value of the Items entity.
// If the Items object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemsMutation) OldYoutubeURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYoutubeURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYoutubeURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYoutubeURL: %w", err)
	}
	return oldValue.YoutubeURL, nil
}

// ClearYoutubeURL clears the value of the "youtube_url" field.
func (m *ItemsMutation) ClearYoutubeURL() {
	m.youtube_url = nil
	m.clearedFields[items.FieldYoutubeURL] = struct{}{}
}

// YoutubeURLCleared returns if the "youtube_url" field was cleared in this mutation.
func (m *ItemsMutation) YoutubeURLCleared() bool {
	_, ok := m.clearedFields[items.FieldYoutubeURL]
	return ok
}

// ResetYoutubeURL resets all changes to the "youtube_url" field.
func (m *ItemsMutation) ResetYoutubeURL() {
	m.youtube_url = nil
	delete(m.clearedFields, items.FieldYoutubeURL)
}

// SetYoutubeID sets the "youtube_id" field.
func (m *ItemsMutation) SetYoutubeID(s string) {
	m.youtube_id = &s
}

// YoutubeID returns the value of the "youtube_id" field in the mutation.
func (m *ItemsMutation) YoutubeID() (r string, exists bool) {
	v := m.youtube_id
	if v == nil {
		return
	}
	return *v, true
}

// OldYoutubeID returns the old "youtube_id" field's value of the Items entity.
// If the Items object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ItemsMutation) OldYoutubeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYoutubeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYoutubeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYoutubeID: %w", err)
	}
	return oldValue.YoutubeID, nil
}

// ClearYoutubeID clears the value of the "youtube_id" field.
func (m *ItemsMutation) ClearYoutubeID() {
	m.youtube_id = nil
	m.clearedFields[items.FieldYoutubeID] = struct{}{}
}

// YoutubeIDCleared returns if the "youtube_id" field was cleared in this mutation.
func (m *ItemsMutation) YoutubeIDCleared() bool {
	_, ok := m.clearedFields[items.FieldYoutubeID]
	return ok
}

// ResetYoutubeID resets all changes to the "youtube_id" field.
func (m *ItemsMutation) ResetYoutubeID() {
	m.youtube_id = nil
	delete(m.clearedFields, items.FieldYoutubeID)
}

// AddCommentIDs adds the "comments" edge to the Comments entity by ids.
func (m *ItemsMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comments entity.
func (m *ItemsMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comments entity was cleared.
func (m *ItemsMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comments entity by IDs.
func (m *ItemsMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comments entity.
func (m *ItemsMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *ItemsMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *ItemsMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// Where appends a list predicates to the ItemsMutation builder.
func (m *ItemsMutation) Where(ps ...predicate.Items) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ItemsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Items).
func (m *ItemsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ItemsMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, items.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, items.FieldUpdatedAt)
	}
	if m.item_id != nil {
		fields = append(fields, items.FieldItemID)
	}
	if m.title != nil {
		fields = append(fields, items.FieldTitle)
	}
	if m.album != nil {
		fields = append(fields, items.FieldAlbum)
	}
	if m.artist != nil {
		fields = append(fields, items.FieldArtist)
	}
	if m.url != nil {
		fields = append(fields, items.FieldURL)
	}
	if m.acr_id != nil {
		fields = append(fields, items.FieldAcrID)
	}
	if m.spotify_url != nil {
		fields = append(fields, items.FieldSpotifyURL)
	}
	if m.spotify_id != nil {
		fields = append(fields, items.FieldSpotifyID)
	}
	if m.youtube_url != nil {
		fields = append(fields, items.FieldYoutubeURL)
	}
	if m.youtube_id != nil {
		fields = append(fields, items.FieldYoutubeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ItemsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case items.FieldCreatedAt:
		return m.CreatedAt()
	case items.FieldUpdatedAt:
		return m.UpdatedAt()
	case items.FieldItemID:
		return m.ItemID()
	case items.FieldTitle:
		return m.Title()
	case items.FieldAlbum:
		return m.Album()
	case items.FieldArtist:
		return m.Artist()
	case items.FieldURL:
		return m.URL()
	case items.FieldAcrID:
		return m.AcrID()
	case items.FieldSpotifyURL:
		return m.SpotifyURL()
	case items.FieldSpotifyID:
		return m.SpotifyID()
	case items.FieldYoutubeURL:
		return m.YoutubeURL()
	case items.FieldYoutubeID:
		return m.YoutubeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ItemsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case items.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case items.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case items.FieldItemID:
		return m.OldItemID(ctx)
	case items.FieldTitle:
		return m.OldTitle(ctx)
	case items.FieldAlbum:
		return m.OldAlbum(ctx)
	case items.FieldArtist:
		return m.OldArtist(ctx)
	case items.FieldURL:
		return m.OldURL(ctx)
	case items.FieldAcrID:
		return m.OldAcrID(ctx)
	case items.FieldSpotifyURL:
		return m.OldSpotifyURL(ctx)
	case items.FieldSpotifyID:
		return m.OldSpotifyID(ctx)
	case items.FieldYoutubeURL:
		return m.OldYoutubeURL(ctx)
	case items.FieldYoutubeID:
		return m.OldYoutubeID(ctx)
	}
	return nil, fmt.Errorf("unknown Items field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case items.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case items.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case items.FieldItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemID(v)
		return nil
	case items.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case items.FieldAlbum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlbum(v)
		return nil
	case items.FieldArtist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtist(v)
		return nil
	case items.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case items.FieldAcrID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcrID(v)
		return nil
	case items.FieldSpotifyURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpotifyURL(v)
		return nil
	case items.FieldSpotifyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpotifyID(v)
		return nil
	case items.FieldYoutubeURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYoutubeURL(v)
		return nil
	case items.FieldYoutubeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYoutubeID(v)
		return nil
	}
	return fmt.Errorf("unknown Items field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ItemsMutation) AddedFields() []string {
	var fields []string
	if m.additem_id != nil {
		fields = append(fields, items.FieldItemID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ItemsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case items.FieldItemID:
		return m.AddedItemID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ItemsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case items.FieldItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemID(v)
		return nil
	}
	return fmt.Errorf("unknown Items numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ItemsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(items.FieldTitle) {
		fields = append(fields, items.FieldTitle)
	}
	if m.FieldCleared(items.FieldAlbum) {
		fields = append(fields, items.FieldAlbum)
	}
	if m.FieldCleared(items.FieldArtist) {
		fields = append(fields, items.FieldArtist)
	}
	if m.FieldCleared(items.FieldURL) {
		fields = append(fields, items.FieldURL)
	}
	if m.FieldCleared(items.FieldAcrID) {
		fields = append(fields, items.FieldAcrID)
	}
	if m.FieldCleared(items.FieldSpotifyURL) {
		fields = append(fields, items.FieldSpotifyURL)
	}
	if m.FieldCleared(items.FieldSpotifyID) {
		fields = append(fields, items.FieldSpotifyID)
	}
	if m.FieldCleared(items.FieldYoutubeURL) {
		fields = append(fields, items.FieldYoutubeURL)
	}
	if m.FieldCleared(items.FieldYoutubeID) {
		fields = append(fields, items.FieldYoutubeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ItemsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ItemsMutation) ClearField(name string) error {
	switch name {
	case items.FieldTitle:
		m.ClearTitle()
		return nil
	case items.FieldAlbum:
		m.ClearAlbum()
		return nil
	case items.FieldArtist:
		m.ClearArtist()
		return nil
	case items.FieldURL:
		m.ClearURL()
		return nil
	case items.FieldAcrID:
		m.ClearAcrID()
		return nil
	case items.FieldSpotifyURL:
		m.ClearSpotifyURL()
		return nil
	case items.FieldSpotifyID:
		m.ClearSpotifyID()
		return nil
	case items.FieldYoutubeURL:
		m.ClearYoutubeURL()
		return nil
	case items.FieldYoutubeID:
		m.ClearYoutubeID()
		return nil
	}
	return fmt.Errorf("unknown Items nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ItemsMutation) ResetField(name string) error {
	switch name {
	case items.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case items.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case items.FieldItemID:
		m.ResetItemID()
		return nil
	case items.FieldTitle:
		m.ResetTitle()
		return nil
	case items.FieldAlbum:
		m.ResetAlbum()
		return nil
	case items.FieldArtist:
		m.ResetArtist()
		return nil
	case items.FieldURL:
		m.ResetURL()
		return nil
	case items.FieldAcrID:
		m.ResetAcrID()
		return nil
	case items.FieldSpotifyURL:
		m.ResetSpotifyURL()
		return nil
	case items.FieldSpotifyID:
		m.ResetSpotifyID()
		return nil
	case items.FieldYoutubeURL:
		m.ResetYoutubeURL()
		return nil
	case items.FieldYoutubeID:
		m.ResetYoutubeID()
		return nil
	}
	return fmt.Errorf("unknown Items field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ItemsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.comments != nil {
		edges = append(edges, items.EdgeComments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ItemsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case items.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ItemsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcomments != nil {
		edges = append(edges, items.EdgeComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ItemsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case items.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ItemsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcomments {
		edges = append(edges, items.EdgeComments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ItemsMutation) EdgeCleared(name string) bool {
	switch name {
	case items.EdgeComments:
		return m.clearedcomments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ItemsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Items unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ItemsMutation) ResetEdge(name string) error {
	switch name {
	case items.EdgeComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown Items edge %s", name)
}
